extension on num {
  int roundDownToNearest(int factor) => (this / factor).floor() * factor;
}

/// The gender of a person.
enum Gender {
  /// A male.
  male,

  /// A female.
  female,
}

abstract class _MyKad {
  _MyKad({this.referenceDate});

  /// A reference date to calculate birthdates and ages at a given time.
  final DateTime? referenceDate;

  /// The MyKad number in YYYYMMDDPB###G
  String get nric;

  /// The formatted MyKad number in YYYYMMDD-PB-###G format.
  String get formattedNric;

  /// The gender of the holder of this MyKad number.
  Gender get gender;

  /// The birthdate of the holder of this MyKad number at midnight relative to
  /// [referenceDate] or to now if [referenceDate] is null. Because of
  /// restrictions on the ISO 8601:2000 format, the minimum birthdate of this
  /// MyKad number is 100 years from now.
  DateTime get birthdate;

  /// The current age of the holder of this MyKad number relative to
  /// [referenceDate] or to now if [referenceDate] is null. Because of
  /// restrictions on the ISO 8601:2000 format, the maximum age of a person is
  /// expected to be 100.
  int get age => (referenceDate ?? DateTime.now()).year - birthdate.year;
}

/// The MyKad format is specified as follows:
/// YYMMDD-PB-###G or, in shortened format, YYMMDDPB###G
///
/// - The first six digits signify the birthdate of the holder of this MyKad
/// number in ISO 8601:2000 format.
/// - The seventh and eight digits specify the holder's birthplace.
/// - The ninth, tenth and eleventh digits is a special number generated by
/// the National Registration Department of Malaysia.
/// - The twelfth digit signifies a person's gender where an odd number
/// represents a male and an even number a female.
///
class MyKad extends _MyKad {
  MyKad._({
    required String nric,
    required DateTime birthdate,
    required Gender gender,
    required DateTime? referenceDate,
  })  : _nric = nric,
        _birthdate = birthdate,
        _gender = gender,
        super(referenceDate: referenceDate);

  /// Parses the [source] string as a [MyKad] class. Throws a [FormatException]
  /// if the source string is invalid. You can also pass in a reference date
  /// to calculate birthdates and ages at a given time.
  factory MyKad.parse(
    String source, {
    DateTime? referenceDate,
  }) {
    final now = referenceDate ?? DateTime.now();
    final matches =
        RegExp(r'^(\d{6})-{0,1}(\d{2})-{0,1}(\d{4})$').allMatches(source);
    if (matches.isEmpty) throw FormatException('Could not parse $source.');

    if (matches.first.groupCount != 3) {
      throw FormatException('Could not parse $source.');
    }

    final components = matches.first.groups([1, 2, 3]);
    if (components.contains(null)) {
      throw const FormatException();
    }

    try {
      final birthdateString = components.elementAt(0)!;

      final birthyearStringInYY = birthdateString.substring(0, 2);
      final birthmonthInMM = int.parse(birthdateString.substring(2, 4));
      final birthdayInDD = int.parse(birthdateString.substring(4, 6));

      final currentCentury = now.year.roundDownToNearest(100);
      final previousCentury = currentCentury - 100;

      final birthYearInCurrentCentury =
          currentCentury + int.parse(birthyearStringInYY);
      final birthdateInCurrentCentury = DateTime(
        birthYearInCurrentCentury,
        birthmonthInMM,
        birthdayInDD,
      );

      final birthYearInPreviousCentury =
          previousCentury + int.parse(birthyearStringInYY);
      final birthdateInPreviousCentury = DateTime(
        birthYearInPreviousCentury,
        birthmonthInMM,
        birthdayInDD,
      );

      final birthdate = birthdateInCurrentCentury.isBefore(now)
          ? birthdateInCurrentCentury
          : birthdateInPreviousCentury;

      // Check to make sure this is an invalid date and that [DateTime] did not
      // overflow a date (i.e. in Dart, DateTime(2011, 99, 99)) is a valid date.
      if (!'${birthdate.year}'.endsWith(birthyearStringInYY) ||
          birthdate.month != birthmonthInMM ||
          birthdate.day != birthdayInDD) {
        throw const FormatException();
      }

      final genderDigit =
          int.parse(components.elementAt(2)!.split('').elementAt(3));
      final gender = genderDigit.isOdd ? Gender.male : Gender.female;

      return MyKad._(
        nric: components.join(),
        birthdate: birthdate,
        gender: gender,
        referenceDate: referenceDate,
      );
    } on FormatException {
      throw FormatException('Could not parse $source.');
    }
  }

  /// Same as [MyKad.parse] but returns null if format is invalid.
  static MyKad? tryParse(
    String source, {
    DateTime? referenceDate,
  }) {
    try {
      return MyKad.parse(source, referenceDate: referenceDate);
    } on FormatException {
      return null;
    }
  }

  final String _nric;
  final DateTime _birthdate;
  final Gender _gender;

  @override
  String get nric => _nric;

  @override
  String get formattedNric => _getFormattedNric(nric);

  @override
  Gender get gender => _gender;

  @override
  DateTime get birthdate => _birthdate;

  static String _getFormattedNric(String nric) {
    final birthdate = nric.substring(0, 6);
    final placeOfBirth = nric.substring(6, 8);
    final specialNumbersWithGender = nric.substring(8, 12);
    return '$birthdate-$placeOfBirth-$specialNumbersWithGender';
  }
}
